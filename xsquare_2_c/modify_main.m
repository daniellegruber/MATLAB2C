%% Get the main file generated by MATLAB Coder from the examples folder
% we will modify the text in this file by commenting out lines we want to
% replaces and inserting new lines

main_text = fileread(fullfile(codegen_dir, 'examples\main.c'));
lines = splitlines(main_text);
main_lines = lines;

%% Declare variables and specify data types

nargv = length(args_split);
nout = length(outs_split);
arg_types = cell(1,nargv);
out_types = cell(1,nout);
arg_numel = zeros(1, nargv);
out_numel = zeros(1, nout);

arg_declare = cell(1,nargv);
out_declare = cell(1,nout);
convert = cell(nargv, 1);

pass_ptr = zeros(1, nargv);
pass_type = cell(1, nargv);
arg_ptr_declare = cell(1, nargv);
arg_ptr = cell(1,nargv);


for i = 1:nargv
    % determine class of variable using the variables saved in
    % workspace/mat file for testing
    arg_types{i} = eval(['class(',args_split{i},')']);
    arg_numel(i) = eval(['numel(', args_split{i}, ')']);

    if arg_numel(i) > 1 % pointer
        pass_ptr(i) = true;
        pass_type{i} = [arg_types{i}, ' *'];
%         arg_declare{i} = [arg_types{i}, ' ', args_split{i}, '[', num2str(arg_numel(i)), '];'];
        arg_ptr{i} = ['p_', args_split{i}];
        args = strrep(args, args_split{i}, arg_ptr{i});
%         arg_ptr_declare{i} = [arg_types{i}, ' *', arg_ptr{i}, ';'];
        arg_declare{i} = [arg_types{i}, ' *', arg_ptr{i}, ';'];
    else
        pass_type{i} = arg_types{i};
        pass_ptr(i) = false;
        arg_declare{i} = [arg_types{i}, ' ', args_split{i}, ';'];
    end

    % if variable is numeric, convert from string to float using atof()
    if strcmp(arg_types{i},'double')
        if pass_ptr(i)
            convert{i} = [deref(arg_ptr{i}) '= atof(argv[', num2str(i), ']);'];
        else
            convert{i} = [args_split{i} '= atof(argv[', num2str(i), ']);'];
        end
    else
        if pass_ptr(i)
            convert{i} = [deref(arg_ptr{i}) '= argv[', num2str(i), '];'];
        else
            convert{i} = [args_split{i} '= argv[', num2str(i), '];'];
        end
    end
    
end

for i = nout
    out_types{i} = eval(['class(',outs_split{i},')']);
    out_numel(i) = eval(['numel(', outs_split{i}, ')']);
    if out_numel(i) > 1 % pointer
        return_ptr = true;
        return_type = [out_types{1}, ' *'];
        out_declare{i} = ['static ', out_types{i}, ' ', outs_split{i},...
            '[', num2str(out_numel(i)), '];'];
        out_ptr = ['p_', outs_split{i}];
        out_ptr_declare = [out_types{1}, ' *', out_ptr, ';'];
    else
        return_type = out_types{1};
        return_ptr = false;
        out_declare{i} = ['static ', out_types{i}, ' ', outs_split{i}, ';'];
    end
end

%% Replace initalization of array outputs with pointers
if return_ptr
comment_idx = [out_types{i}, ' ', outs_split{i}, '[', num2str(out_numel(i)), '];'];
insertion = out_ptr_declare; 
[main_lines, insert_idx] = modify_code(main_lines, comment_idx, 'comment');
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);
end

%% Determine whether number of arguments is correct
check_arg = cell(4,1);
check_arg{1} = ['if (argc != ', num2str(nargv + 1), ') {'];
check_arg{2} = ['printf(''Expected ', num2str(nargv) , ' arguments: ', args, '\n'');'];
check_arg{3} = 'exit(-1);';
check_arg{4} = '}';

%% For testing

check_command = cell(5,1);
check_command{1} = 'int i=0;';
check_command{2} = 'printf("\nexe name=%s", argv[0]);';
check_command{3} = 'for (i=1; i< argc; i++) {';
check_command{4} = 'printf("\narg%d=%s", i, argv[i]);';
check_command{5} = ' }';

%% Insert declaration of variables and argument number check

if return_ptr
    insertion = [{'printf("hey");'}; arg_declare; out_ptr_declare; {'printf("hello");'}; check_arg; convert; check_command];
else
    insertion = [arg_declare; out_declare; check_arg; convert; check_command];
end
comment_idx = {'(void)argc', '(void)argv'};
[main_lines, comment_idx] = modify_code(main_lines, comment_idx, 'comment');

insert_idx = comment_idx(end);
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

%% Replace ... in declarations/definitions of main_cfun_name(...) with arg declarations

[fun_declare_define, fdd_idx, ~, ~] = fun_distinguish(main_lines, cfun_name);

modify_idx = find(fdd_idx);
old = regexp(fun_declare_define, '\(.*\)', 'match', 'once');
joined_declarations = strjoin(strrep(arg_declare, ';',''), ', ');
new = ['(',joined_declarations,')'];
insertion = strrep(fun_declare_define, old, new);

%% Replace void in declarations/definitions of main_cfun_name output return type
old = extractBefore(fun_declare_define, ['main_', cfun_name]);
% if return_ptr
%     new = 'static * ';
% else
%     new = ['static ', out_types{1}, ' '];
% end
new = ['static ', return_type, ' '];
insertion = strrep(insertion, old, new);

[main_lines, insert_idx] = modify_code(main_lines, modify_idx, 'comment');
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

%% Replace ... in calls of main_cfun_name(...) and cfun_name(...) with args

[~, ~, fun_calls, fc_idx] = fun_distinguish(main_lines, cfun_name);

modify_idx = find(fc_idx);
old = regexp(fun_calls, '\(.*\)', 'match', 'once');
new = ['(',args,')'];
insertion = strrep(fun_calls, old, new);

%% Make sure to return output in calls of main_cfun_name and cfun_name
insertion = regexp(insertion, ['[/<(main_|',cfun_name,')].*'],'match','once');
if return_ptr
    insertion = cellfun(@(x) [out_ptr, ' = ', x], insertion, 'UniformOutput', false);

    check_ptr = cell(4,1);
    check_ptr{1} = 'int k;';
    check_ptr{2} = ['for ( k = 0; k < ', num2str(out_numel(1)), '; k++ ) {'];
    check_ptr{3} = ['    printf("*(', out_ptr, ' + [%d]) : %d\n", k, *(', out_ptr, ' + k) );'];   
    check_ptr{4} = '}';

    insertion2 = cell(length(insertion),1);
    for i = 1:length(insertion)
        insertion2{i} = [insertion(i); check_ptr];
    end

else
    insertion2 = cellfun(@(x) [outs, ' = ', x], insertion, 'UniformOutput', false);
end

[main_lines, insert_idx] = modify_code(main_lines, modify_idx, 'comment');
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion2);

%% Replace ... in declarations/definitions of xxx_cfun_name(...) with arg declarations

% Search directory for files containing calls (maybe unnecessary?)
files_and_folders = dir(codegen_dir);     
files = files_and_folders(~([files_and_folders.isdir]));
for i = 1:length(files)
    filename = files(i).name;

    if endsWith(filename,{'.c','.h'}) && ~strcmp('main.c', filename)
        file_text = fileread(fullfile(codegen_dir,filename));
        lines = splitlines(file_text);
        file_lines = lines;       
        
        [fun_declare_define, fdd_idx, ~, ~] = fun_distinguish(file_lines, cfun_name);
        modify_idx = find(fdd_idx);

        if ~isempty(modify_idx)
            disp(['Modifying ', filename])
            old = regexp(fun_declare_define, '\(.*\)', 'match', 'once');
            joined_declarations = strjoin(strrep(arg_declare, ';',''), ', ');
            new = ['(',joined_declarations,')'];
            insertion = strrep(fun_declare_define, old, new);
            
            % Replace void with output return type
            
            insertion = strrep(insertion, 'void', return_type);
            
            [file_lines, insert_idx] = modify_code(file_lines, modify_idx, 'comment');
            [file_lines, ~] = modify_code(file_lines, insert_idx, 'insert', 'insertion', insertion);

            writetable(cell2table(file_lines), fullfile(codegen_dir,'tmp.txt'), 'WriteVariableNames', false, 'QuoteStrings','none')
            movefile(fullfile(codegen_dir,'tmp.txt'),fullfile(codegen_dir, filename))

        end   
    end
end

%% Make sure cfun initializes and returns output
cfun_text = fileread(fullfile(codegen_dir, [cfun_name, '.c']));
lines = splitlines(cfun_text);
cfun_lines = lines;

if isempty(find(contains(cfun_lines, out_declare), 1))
    insertion = out_declare;
    insert_idx = find(contains(cfun_lines, '{'));
    insert_idx = insert_idx(1);
    [cfun_lines, ~] = modify_code(cfun_lines, insert_idx, 'insert', 'insertion', insertion);
end

if isempty(find(contains(cfun_lines, 'return'), 1))
    insertion = ['return ', outs, ';'];
    insert_idx = find(contains(cfun_lines, '}'));
    insert_idx = insert_idx(end) - 1;
    [cfun_lines, ~] = modify_code(cfun_lines, insert_idx, 'insert', 'insertion', insertion);
end

%% Replace instances of indexed array elements with pointer + offset
comment_lines = contains(cfun_lines,{'//','/*'});
for i = 1:nargv
    if pass_ptr(i)
        comment_idx = regexp(cfun_lines, ['\s', args_split{i}, '\s'], 'match', 'once'); % MAKE SURE THIS ISN'T MATCH ONCE
        comment_idx = find(~cellfun(@isempty, comment_idx) & ~comment_lines);
        insertion = regexprep(cfun_lines(comment_idx), ['\s', args_split{i}, '\s'], ['\s', arg_ptr{i}, '\s']);
        [cfun_lines, insert_idx] = modify_code(cfun_lines, comment_idx, 'comment');
        [cfun_lines, ~] = modify_code(cfun_lines, insert_idx, 'insert', 'insertion', insertion);

        comment_idx = regexp(cfun_lines, ['\<', args_split{i}, '\[\d*\]\>'], 'match', 'once');
        comment_idx = find(~cellfun(@isempty, comment_idx) & ~comment_lines);
        insertion = arr_2_ptr_idx(cfun_lines(comment_idx), args_split{i}, arg_ptr{i});
        [cfun_lines, insert_idx] = modify_code(cfun_lines, comment_idx, 'comment');
        [cfun_lines, ~] = modify_code(cfun_lines, insert_idx, 'insert', 'insertion', insertion);
    end
end

%% Include stdio.h
line = '/* Include files */';
insertion = '#include <stdio.h>';
insert_idx = find(contains(main_lines, line));
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

%% Write to file
% Create a new main.c file in the codegen folder

writetable(cell2table(main_lines), fullfile(codegen_dir,'tmp.txt'), 'WriteVariableNames', false, 'QuoteStrings','none')
movefile(fullfile(codegen_dir,'tmp.txt'),fullfile(codegen_dir,'main.c'))

% writetable(cell2table(mainh_lines), fullfile(codegen_dir,'tmp.txt'), 'WriteVariableNames', false, 'QuoteStrings','none')
% movefile(fullfile(codegen_dir,'tmp.txt'),fullfile(codegen_dir,'main.h'))

writetable(cell2table(cfun_lines), fullfile(codegen_dir,'tmp.txt'), 'WriteVariableNames', false, 'QuoteStrings','none')
movefile(fullfile(codegen_dir,'tmp.txt'),fullfile(codegen_dir,[cfun_name, '.c']))

%% Function: distinguish between function declarations/definitions and calls
function [fun_declare_define, fdd_idx, fun_calls, fc_idx] = fun_distinguish(code, cfun_name)

comment_lines = contains(code,{'//','/*'});

% fun_declare_define = regexp(code, ['.*[a-zA-Z*]+\s(main_|)',cfun_name,'.*'],'match','once');
fdd_idx = regexp(code, ['.*[a-zA-Z*]+\s(main_|)',cfun_name,'\>'],'match','once');
% fdd_idx = ~cellfun(@isempty, fun_declare_define) & ~comment_lines;
fdd_idx = ~cellfun(@isempty, fdd_idx) & ~comment_lines;
% fun_declare_define = fun_declare_define(fdd_idx);
fun_declare_define = code(fdd_idx);

fun_calls = regexp(code, ['.*',cfun_name,'\(.*\).*'],'match','once');
fc_idx = ~cellfun(@isempty, fun_calls) & ~fdd_idx & ~comment_lines;
fun_calls = fun_calls(fc_idx);

end

%% Function: modify code
function [new_code, modify_idx] = modify_code(old_code, modify_idx, modification, varargin)

p = inputParser;

isValidModification = @(x) ismember(x, {'comment', 'insert', 'replace', 'remove'});
isValidIdx = @(x) iscellstr(x) || ischar(x) || isnumeric(x);
isValidSegment = @(x) (iscellstr(x) || isnumeric(x)) && length(x) == 2;
isValidInsert = @(x) iscell(x) || ischar(x);

addRequired(p, 'old_code', @iscellstr);
addRequired(p, 'modify_idx', isValidIdx);
addRequired(p, 'modification', isValidModification)
addParameter(p, 'insertion', {}, isValidInsert);
addParameter(p, 'replacement', {}, isValidInsert);
addParameter(p, 'search_segment', {}, isValidSegment); % search between given start and end strings


parse(p, old_code, modify_idx, modification, varargin{:});

old_code = p.Results.old_code;
modify_idx = p.Results.modify_idx;
modification = p.Results.modification;
insertion = p.Results.insertion;
replacement = p.Results.replacement;
search_segment = p.Results.search_segment;

comment_lines = contains(old_code,{'//','/*'});

% Search segment
if isempty(search_segment)
    if ischar(modify_idx) || iscellstr(modify_idx)
        modify_idx = find(contains(old_code, modify_idx) & ~comment_lines);
    end
    
else
    if iscellstr(search_segment)
        line1 = search_segment{1};
        line2 = search_segment{2};
        idx1 = find(contains(old_code, line1));
        idx2 = find(contains(old_code, line2));
        idx2 = idx2(idx2 > idx1);
        idx2 = idx2(1);
        
    else
        idx1 = search_segment(1);
        idx2 = search_segment(2);
        
    end
        
    modify_idx = find(contains(old_code(idx1:idx2), modify_idx) &...
        ~comment_lines(idx1:idx2)) + idx1 - 1;
end

% Comment out code
if strcmp(modification, 'comment')
    new_code = comment_code(old_code, modify_idx);

% Insert code
elseif strcmp(modification, 'insert')
    new_code = insert_code(old_code, insertion, modify_idx);

% Replace code
elseif strcmp(modification, 'replace')
    new_code = replace_code(old_code, replacement, modify_idx);

% Delete code 
elseif strcmp(modification, 'delete')
    new_code = delete_code(old_code, modify_idx);

end

end

%% Helper functions

% Comment out code
function new_code = comment_code(old_code, comment_idx)
    commented_code = cellfun(@(x) ['//', x], old_code(comment_idx), 'UniformOutput', false);
    new_code = old_code;
    new_code(comment_idx) = commented_code;
end

% Remove code
function new_code = delete_code(old_code, delete_idx)
    new_code = old_code;
    new_code(delete_idx) = {};
end
   

% Indent code based on indentation of previous line
function indented_code = indent_code(prev_line, new_line)
    if length(prev_line) < 3
        indent = {};
    elseif ~isempty(regexp(prev_line(1:3), '//\s', 'match'))
        indent = regexp(prev_line, '\s*', 'match');
        indent = indent{1};
    elseif isempty(regexp(prev_line(1),'\s','match'))
        indent = {};
    else
        indent = regexp(prev_line, '\s*', 'match');
        indent = indent{1};
    end

    if iscell(new_line)
        indented_code = cellfun(@(x) [indent, x], new_line, 'UniformOutput', false);
    else
        indented_code = [indent, new_line];
    end
    
end

% Insert code
function inserted_code = insert_code(old_code, insertion, insert_idx)
    inserted_code = old_code;
    for i = 1:length(insert_idx)
        if length(insertion) == length(insert_idx)
            tmp = insertion{i};
            if ischar(tmp) || i == 1
                idx = insert_idx(i) + i - 1;
            else
                idx = insert_idx(i) + i + length(tmp) - 2;
                
            end
        else
            tmp = insertion;
            idx = insert_idx(i) + i - 1;
        end
        if ~iscellstr(tmp) && ~ischar(tmp)
            tmp = vertcat(tmp{:});
        else
            
        end
        prev_line = inserted_code{idx};
        tmp = indent_code(prev_line, tmp);
        inserted_code = [inserted_code(1:idx); tmp; inserted_code(idx+1:end)];
        
    end
end

% Replace code
function replaced_code = replace_code(old_code, replacement, replace_idx)
    replaced_code = old_code;
    replaced_code(replace_idx) = replacement;
end

%% Function: converte indexed array element to pointer + offset
function str = arr_2_ptr_idx(str, arr, ptr)

offset = regexp(str, ['(?<=', arr, '\[)\d*(?=\])'], 'match');
offset = unique(horzcat(offset{:}));
for i = 1:length(offset)
    str = regexprep(str, [arr, '\[', offset{i}, '\]'], ['*(', ptr, ' + ', offset{i}, ')']);
end

end

%% Function: dereference pointer
function deref_ptr = deref(ptr)
deref_ptr = ['*', ptr];
end



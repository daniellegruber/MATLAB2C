%% Get the main file generated by MATLAB Coder from the examples folder
% we will modify the text in this file by commenting out lines we want to
% replaces and inserting new lines

main_text = fileread(fullfile(codegen_dir, 'examples\main.c'));
lines = splitlines(main_text);
main_lines = lines;

mainh_text = fileread(fullfile(codegen_dir, 'examples\main.h'));
lines = splitlines(mainh_text);
mainh_lines = lines;

%%
%eval(['size(', args_split{1}, ')'])
%eval(['reshape(', args_split{1}, ', 1, numel(',args_split{1},'))'])


%% Declare variables and specify data types

nargv = length(args_split);
nout = length(outs_split);
arg_classes = cell(1,nargv);
out_classes = cell(1,nout);
arg_numel = zeros(1, nargv);
out_numel = zeros(1, nout);

arg_declaration = cell(1,nargv);
out_declaration = cell(1,nout);
convert = cell(nargv, 1);

for i = 1:nargv
    % determine class of variable using the variables saved in
    % workspace/mat file for testing
    arg_classes{i} = eval(['class(',args_split{i},')']);
    arg_numel(i) = eval(['numel(', args_split{i}, ')']);
    if arg_numel(i) == 1
        arg_declaration{i} = [arg_classes{i}, ' ', args_split{i}, ';'];
    else
        arg_declaration{i} = [arg_classes{i}, ' ', args_split{i}, '[', num2str(arg_numel(i)), '];'];
    end

    % if variable is numeric, convert from string to float using atof()
    if strcmp(arg_classes{i},'double')
        convert{i} = [args_split{i} '= atof(argv[', num2str(i), ']);'];
    else
        convert{i} = [args_split{i} '= argv[', num2str(i), '];'];
    end
    
end

for i = nout
    out_classes{i} = eval(['class(',outs_split{i},')']);
    out_numel(i) = eval(['numel(', outs_split{i}, ')']);
    if out_numel(i) == 1
        out_declaration{i} = [out_classes{i}, ' ', outs_split{i}, ';'];
    else
        out_declaration{i} = [out_classes{i}, ' ', outs_split{i}, '[', num2str(out_numel(i)), '];'];
    end

end

%% Determine whether number of arguments is correct
check_arg = cell(4,1);
check_arg{1} = ['if (argc != ', num2str(nargv + 1), ') {'];
check_arg{2} = ['printf(''Expected ', num2str(nargv) , ' arguments: ', args, '\n'');'];
check_arg{3} = 'exit(-1);';
check_arg{4} = '}';

%% For testing

check_command = cell(5,1);
check_command{1} = 'int i=0;';
check_command{2} = 'printf("\nexe name=%s", argv[0]);';
check_command{3} = 'for (i=1; i< argc; i++) {';
check_command{4} = 'printf("\narg%d=%s", i, argv[i]);';
check_command{5} = ' }';

%% Insert declaration of variables and argument number check

insertion = [arg_declaration; out_declaration; check_arg; check_command];
comment_idx = {'(void)argc', '(void)argv'};
[main_lines, comment_idx] = modify_code(main_lines, comment_idx, 'comment');

insert_idx = comment_idx(end);
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);


%% Make sure to get output of main_cfun_name in main function
insertion = [outs, ' = main_', cfun_name, '(', args, ');'];
comment_idx = ['main_', cfun_name];
segment = {'int main(int argc, char **argv)', 'return'};
[main_lines, insert_idx] = modify_code(main_lines, comment_idx, 'comment', 'search_segment',segment);
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

% Switch out return 0 with return (output)
insertion = ['return ', outs, ';'];
comment_idx = 'return';
[main_lines, insert_idx] = modify_code(main_lines, comment_idx, 'comment', 'search_segment',segment);
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

% Switch return type of main with return type of (output)
% insertion = [out_classes{1}, ' ', regexp(segment{1}, 'main.*', 'match', 'once')];
% comment_idx = segment{1};
% [main_lines, insert_idx] = modify_code(main_lines, comment_idx, 'comment', 'search_segment',segment);
% [main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

%% Also need to change the declaration in other files (main.h, cfun)

%% Distinguish between function declarations/definitions and calls
comment_lines = contains(main_lines,{'//','/*'});

fun_declare_define = regexp(main_lines, ['.*[a-zA-Z]+\s(main_|)',cfun_name,'.*'],'match','once');
fdd_idx = ~cellfun(@isempty, fun_declare_define) & ~comment_lines;
fun_declare_define = fun_declare_define(fdd_idx);

fun_calls = regexp(main_lines, ['.*',cfun_name,'\(.*\).*'],'match','once');
fc_idx = ~cellfun(@isempty, fun_calls) & ~fdd_idx & ~comment_lines;
fun_calls = fun_calls(fc_idx);

%% Replace ... in declarations/definitions of main_cfun_name(...) with arg declarations

modify_idx = find(fdd_idx);
old = regexp(fun_declare_define, '\(.*\)', 'match', 'once');
joined_declarations = strjoin(strrep(arg_declaration, ';',''), ', ');
new = ['(',joined_declarations,')'];
insertion = strrep(fun_declare_define, old, new);

%% Replace void in declarations/definitions of main_cfun_name output return type
old = extractBefore(fun_declare_define, ['main_', cfun_name]);
new = ['static ', out_classes{1}, ' '];
insertion = strrep(insertion, old, new);

[main_lines, insert_idx] = modify_code(main_lines, modify_idx, 'comment');
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

%% Replace ... in calls of main_cfun_name(...) and cfun_name(...) with args

modify_idx = find(fc_idx);
old = regexp(fun_calls, '\(.*\)', 'match', 'once');
new = ['(',args,')'];
insertion = strrep(fun_calls, old, new);

[main_lines, insert_idx] = modify_code(main_lines, modify_idx, 'comment');
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

%% Make sure to return output of cfun
% line = fun_call;
% insert_idx = find(contains(main_lines,line));
% insertion = cell(2,1);
% insertion{1} = 'printf("\nl=%f",l);';
% insertion{2} = ['return ', outs_split{1}, ';'];
% [main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);

%% Include stdio.h
line = '/* Include files */';
insertion = '#include <stdio.h>';
insert_idx = find(contains(main_lines, line));
[main_lines, ~] = modify_code(main_lines, insert_idx, 'insert', 'insertion', insertion);


%% Write to file
% Create a new main.c file in the codegen folder

writetable(cell2table(main_lines), fullfile(codegen_dir,'main.txt'), 'WriteVariableNames', false, 'QuoteStrings','none')
movefile(fullfile(codegen_dir,'main.txt'),fullfile(codegen_dir,'main.c'))

%% Helper functions

% Distinguish between function declarations/definitions and calls

comment_lines = contains(main_lines,{'//','/*'});

fun_declare_define = regexp(main_lines, ['.*[a-zA-Z]+\s(main_|)',cfun_name,'.*'],'match','once');
fdd_idx = ~cellfun(@isempty, fun_declare_define) & ~comment_lines;
fun_declare_define = fun_declare_define(fdd_idx);

fun_calls = regexp(main_lines, ['.*',cfun_name,'\(.*\).*'],'match','once');
fc_idx = ~cellfun(@isempty, fun_calls) & ~fdd_idx & ~comment_lines;
fun_calls = fun_calls(fc_idx);

% Modify code
function [new_code, modify_idx] = modify_code(old_code, modify_idx, modification, varargin)

p = inputParser;

isValidModification = @(x) ismember(x, {'comment', 'insert', 'replace', 'remove'});
isValidIdx = @(x) iscellstr(x) || ischar(x) || isnumeric(x);
isValidSegment = @(x) (iscellstr(x) || isnumeric(x)) && length(x) == 2;
isValidInsert = @(x) iscell(x) || ischar(x);

addRequired(p, 'old_code', @iscellstr);
addRequired(p, 'modify_idx', isValidIdx);
addRequired(p, 'modification', isValidModification)
addParameter(p, 'search_dir', {}, @isfolder); % search across files in specified folder
addParameter(p, 'insertion', {}, isValidInsert);
addParameter(p, 'replacement', {}, isValidInsert);
addParameter(p, 'search_segment', {}, isValidSegment); % search between given start and end strings


parse(p, old_code, modify_idx, modification, varargin{:});

old_code = p.Results.old_code;
modify_idx = p.Results.modify_idx;
modification = p.Results.modification;
search_dir = p.Results.search_dir;
insertion = p.Results.insertion;
replacement = p.Results.replacement;
search_segment = p.Results.search_segment;

% Search directory
if ~isempty(search_dir)
    files_and_folders = dir(search_dir);     
    files = files_and_folders(~([files_and_folders.isdir]));
    for i = 1:length(files)
        filename = files(i).name;
    
        if isfile(filename)
            file_text = fileread(filename);
            lines = splitlines(file_text);
            file_lines = lines;
            modify_idx = find(contains(file_lines, modify_idx));        
            
            if ~isempty(modify_idx)
                disp(['Modifying ', filename])
                old_code = file_lines;
                [new_code, modify_idx] = modify_code_main(old_code, modify_idx, modification, ...
                    insertion, replacement, search_segment);
                if ~strcmp(mfilename, filename)
                    writetable(cell2table(file_lines), fullfile(codegen_dir,'tmp.txt'), 'WriteVariableNames', false, 'QuoteStrings','none')
                    movefile(fullfile(codegen_dir,'tmp.txt'),fullfile(codegen_dir, filename))
                end
            end   
        end
    end
else
    [new_code, modify_idx] = modify_code_main(old_code, modify_idx, modification, ...
            insertion, replacement, search_segment);
end


end

function [new_code, modify_idx] = modify_code_main(old_code, modify_idx, modification, ...
    insertion, replacement, search_segment)

comment_lines = contains(old_code,{'//','/*'});

% Search segment
if isempty(search_segment)
    if ischar(modify_idx) || iscellstr(modify_idx)
        modify_idx = find(contains(old_code, modify_idx) & ~comment_lines);
    end
    
else
    if iscellstr(search_segment)
        line1 = search_segment{1};
        line2 = search_segment{2};
        idx1 = find(contains(old_code, line1));
        idx2 = find(contains(old_code, line2));
        idx2 = idx2(idx2 > idx1);
        idx2 = idx2(1);
        
    else
        idx1 = search_segment(1);
        idx2 = search_segment(2);
        
    end
        
    modify_idx = find(contains(old_code(idx1:idx2), modify_idx) &...
        ~comment_lines(idx1:idx2)) + idx1 - 1;
end

% Comment out code
if strcmp(modification, 'comment')
    new_code = comment_code(old_code, modify_idx);

% Insert code
elseif strcmp(modification, 'insert')
    new_code = insert_code(old_code, insertion, modify_idx);

% Replace code
elseif strcmp(modification, 'replace')
    new_code = replace_code(old_code, replacement, modify_idx);

% Delete code 
elseif strcmp(modification, 'delete')
    new_code = delete_code(old_code, modify_idx);

end

end

%% Helper functions

% Comment out code
function new_code = comment_code(old_code, comment_idx)
    commented_code = cellfun(@(x) ['//', x], old_code(comment_idx), 'UniformOutput', false);
    new_code = old_code;
    new_code(comment_idx) = commented_code;
end

% Remove code
function new_code = delete_code(old_code, delete_idx)
    new_code = old_code;
    new_code(delete_idx) = {};
end
   

% Indent code based on indentation of previous line
function indented_code = indent_code(prev_line, new_line)
    if length(prev_line) < 3
        indent = {};
    elseif ~isempty(regexp(prev_line(1:3), '//\s', 'match'))
        indent = regexp(prev_line, '\s*', 'match');
        indent = indent{1};
    elseif isempty(regexp(prev_line(1),'\s','match'))
        indent = {};
    else
        indent = regexp(prev_line, '\s*', 'match');
        indent = indent{1};
    end

    if iscell(new_line)
        indented_code = cellfun(@(x) [indent, x], new_line, 'UniformOutput', false);
    else
        indented_code = [indent, new_line];
    end
    
end

% Insert code
function inserted_code = insert_code(old_code, insertion, insert_idx)
    inserted_code = old_code;
    for i = 1:length(insert_idx)
        if length(insertion) == length(insert_idx)
            tmp = insertion{i};
        else
            tmp = insertion;
        end
        if ~iscellstr(tmp) && ~ischar(tmp)
            tmp = vertcat(tmp{:});
        end
        idx = insert_idx(i) + i - 1;
        prev_line = old_code{idx};
        tmp = indent_code(prev_line, tmp);
        inserted_code = [inserted_code(1:idx); tmp; inserted_code(idx+1:end)];
        
    end
end

% Replace code
function replaced_code = replace_code(old_code, replacement, replace_idx)
    replaced_code = old_code;
    replaced_code(replace_idx) = replacement;
end


